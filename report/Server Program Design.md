[TOC]

# Server Program Design

In this part, I will not go through too much about how we make the website and how we make the server application, we purely focus on how the database is cooperating with the program.



## ORM

ORM stands for object relational mappings. Let's consider a case: the query SQL sentense is sent to database in String, and returns with a byte array. How can we manage the data in high level programming language? I guess no one would like to handle the raw byte array or record set, they are too hard to use and not intuitive.

Just have a look, if we have a table that contains ID, Name and Password, how about putting them into a class like this?

```java
public class User {
	int id;
	String name;
	String password;
}
```

Each row in this table can be mapped to an object like this, and the object can be pass to the program directly without caring all its data type since they are finally confirmed by the ORM mappings.

It is very convenient and reduce the mistakes when you are dealing with the raw query result in your program. Also, using ORM help you away from SQL injection attack.



## Code First

Once we have ORM, it is easy for us to understand what is code first design pattern, since the entity classes can be defined in a program, obviously we can generate the database model based on the code. For example, we defined the User entity in our program, we can map it to the database automatically, without typing any SQL commands, just as follows:

![image-20201226043358238](C:\Users\13540\AppData\Roaming\Typora\typora-user-images\image-20201226043358238.png)

![image-20201226031846828](https://pic-bed.xyz/res/userFiles/czf/142.png)

It is pretty convenient since we don't have to set up the database before we write the code, it can be auto generated according to your classes.



## How to query without SQL commands?

Given that the ORM framework can help you convert raw bytes to a class or a class model to a database model, how about making something more interesting? How about......no SQL commands at all? Are you serious?

Yes, of course, since all the attributes are perfectly mapped to a class, so making conversions are not difficult at all. For example, if I want to find out the users who are born after year 2000. In SQL commands, we have to write:

```sql
select * from `User` where `Birthday` > '2000-01-01'
```

But, with the ORM, you can write down a prototype function that return a list of users, like:

```java
public List<Users> findAllByBirthDayGreaterThan(Date date);
```

!!! Be reminded that, it is only a prototype of a function, you don't have to implement it manually since it can be generated by the ORM framework. With this strategy, we can create a set of prototype functions like:

```java
public User findById(int id);
public List<User> findAllByxxxxx(xxxx xxxx);
public User save(User user); //Insert or Update
public User deleteById(int id);
public List<User> deleteAllByxxxx(xxxx xxxx);
public User delete(User user);
……
```

By making combinations of class members, you can create a lot of function to substitude SQL commands. Actually, I didn't write any raw SQL query commands in my program but all prototype functions.



## Not enough? A cutting-edge technology is coming.

Here is a brand new technology that helps you greately reduce intermediate tables. We have to go back to a situation of one-to-many mapping(don't care about many-to-many mapping since it can be reduced to one-to-many mapping.) Just consider, one student can buy several commodities, so there is a one-to-many relationship. Traditionally, we will set up a intermediate table that consists of primary key of student and primary key of commodity together to store them. 

But, this strategy has many disadvantages:

1, a lot of redundants in data. Since all these two public keys are duplicate and it is unnecessary at all! (Even in this case, it still satisfy 3NF, but not BCNF.)

2, The volume of this intermediate table is the Cartesian product of these two tables. For example, if there are 10000 users, and each user has bought 100 commodities on average, it is 1 million! Not to say the online-shopping platform like Taobao and JD, the Cartesian product space can be up to trillion, it is impossible to store them in a database!

So, We are going to introduce "Navigation".

Let's follow our "instinct", it is very natural for us to build entities like this:

```java
public class User {
    int id;
    String name;
    
    List<Commodity> Commodities;
}

public class Commodity {
    int id;
    String introduction;
    
    User seller;
}
```

Actually it can not be built in program since it has circular reference, because Commodidy has User and User has a list of Commodities and each Commodity depends on the User again and again, then cause a lot of errors.

But, making some tricks can achieve this goal, let's have a look. If you have extra information to tell the database that the dependency of these two, it will have solution. For example, Commodity has dependency to User, and User is defined to be active, and Commodity is defined to be passive, then, these case can be converted to:

```java
public class User {
    int id;
    String name;
    // no extra dependencies
}

public class Commodity {
    int id;
    String introduction;
    
    int sellerId; // foreign key to User
}
```

In these way, the circular reference is finally solved. So, if we keep the former version in our program, but maintain the latter one in database, then we can both follow our "instinct" and satisfy the requirement of database. Sounds so good!

I will show you the real code that we implement in our project:

```c#
public class Student : User {
    [StringLength(40)] public string College { get; set; }
    [StringLength(40)] public string Major { get; set; }
    [Required] public string Dormitory { get; set; } = "";
    [JsonIgnore] public List<Commodity> AllMyCommodities { get; set; } = new List<Commodity>();
    [JsonIgnore] public List<SalesRecord> Sold { get; set; } = new List<SalesRecord>();
    [JsonIgnore] public List<SalesRecord> Bought { get; set; } = new List<SalesRecord>();
}
```

Be careful of the `AllMyCommodities`, `Sold` and `Bought` attribute in the class, and compare it with the database model:

![image-20201226052714522](https://pic-bed.xyz/res/userFiles/czf/148.png)

In Commodities:

![image-20201226052830200](https://pic-bed.xyz/res/userFiles/czf/146.png)

In SalesRecords:

![image-20201226052916524](https://pic-bed.xyz/res/userFiles/czf/147.png)

You can see that, the real entity model is different from what we defined in the code, how is it made? That is the magic of Navigation, if you would like to know more, check this website https://docs.microsoft.com/zh-cn/ef/core/modeling/relationships?tabs=fluent-api%2Cfluent-api-simple-key%2Csimple-key I don't have too much time to explain it in my report because it is very very complicated.



## Asynchronous IO

Query in database is time consuming because of heavy IO work. Let assume that, a query will execute for 1 second, and your computer has only 1 CPU core to serve, what will the situation like? When 张三 is going to request, it will cause a long query, during the execution time, 李四 has come in. Because CPU has only one core, and 张三 has been blocked because of waiting for the database. So 李四 must wait until the former request finish.

But, is it necessary for 李四 to wait? Probably not, while 张三 is waiting for IO, the CPU is idle, and it is waiting for disks. So, if we can schedule the IO process and the requests, and hang up them at the correct time, 李四 can be served while 张三 is waiting for IO. Just like, you can have your rice cooked while you are cooking your dishes.

To achieve this schedule, we need to use asynchronous IO methods to do, if you would like to know more, you can see the NIO of C# or NIO for Java for detail, I don't want to get into this since this problem belongs to System Schedule, not only the database.



## Advanced Concurrent Control

Buying things can fall into race condition, because 张三 and 李四 could access the commodity at the same time. To solve this problem, we have to use optimistic lock to solve it. In short, an optimistic lock will not block concurrent read or write if no collision happens. It will block you only if you are attemped to modify a critical data. For example, if 张三 is buying an iPhone, 李四 is buying a Samsung, there is no need to lock the data since there will not be any concurrent modification problem. The optimistic block will only be effective when 张三 and 李四 is buying the same thing. So in this case, the concurrent performance is much better.



## Refernces:

Here I noted some articals written by myself, which can explain some problems in detail, please check:

https://pic-bed.xyz/res/userFiles/czf/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B.pdf

https://pic-bed.xyz/res/userFiles/czf/MySQL%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98.pdf